import org.apache.commons.lang3.*;
import java.util.*;

public class SDES {
    
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("Enter the length of the plaintext/ciphertext:");
        int n=scanner.nextInt();
        byte[] plainText = new byte[n];
        
        System.out.println("Enter byte values:");
        for(int i=0; i<n; i++)     
            plainText[i]=scanner.nextByte();
        
        System.out.println(".......................................\n");
        
        //
        // encrypt or decrypt
        //
        
    }
  
    //encrypt
    public static byte[] encrypt(byte[] rawKey, byte[] plainText){
        byte[] cipher = new byte[plainText.length];
        
        //IP (initial permutation)
        int[] IP = {2, 6, 3, 1, 4, 8, 5, 7};
        byte[] IPResult = permutation(plainText, IP);
        
        // The video showed that after initial permutation the output index would be 1,5,2,0,7,4,6
        // so maybe we can set the cypherText to those indicies of the plaintext and run it through the rest
        // of the algorithims
        
        /**
           cypher = { plainText[1], plainText[5], plainText[2], plainText[0], plainText[3], 
           plainText[7], plainText[4], plainText[6] }
           
          **/
        
        KeyGen keyGen = new KeyGen(rawKey);
        byte[] K1 = keyGen.getK1();
        byte[] K2 = keyGen.getK2();
        
        
        //fK round 1
        cipher = fK(IPResult, K1);

        
        //Swap = left shift by 4
        cipher = leftShift(cipher, cipher.length/2);
        
        
        //fk round 2
        cipher = fK(cipher, K2);
        
        
        //IP-1 (inverse)
        int[] inverseIP = {4, 1, 3, 5, 7, 2, 8, 6};
        cipher = permutation(cipher, inverseIP);
        
        return cipher;
    }
    
    //decrypt
    public static byte[] decrypt(byte[] rawkey, byte[] ciphertext){
        byte[] plaintext = new byte[ciphertext.length];
        
        //IP (initial permutation)
        int[] IP = {2, 6, 3, 1, 4, 8, 5, 7};
        byte[] IPResult = permutation(ciphertext, IP);
        
        //generate keys
        KeyGen keyGen = new KeyGen(rawkey);
        byte[] K1 = keyGen.getK1();
        byte[] K2 = keyGen.getK2();
        
        
        //fK round 2
        plaintext = fK(IPResult, K2);

        
        //Swap = left shift by 4
        plaintext = leftShift(plaintext, plaintext.length/2);
        
        
        //fk round 1
        plaintext = fK(plaintext, K1);
        
        //IP-1 (inverse)
        int[] inverseIP = {4, 1, 3, 5, 7, 2, 8, 6};
        plaintext = permutation(plaintext, inverseIP);
        
        return plaintext;
        
        
    }
    
    //fK function
    public static byte[] fK(byte[] input, byte[] key){
        byte[] output = new byte[input.length];
        
        //split 
        int splitSize = input.length/2;
        byte[] IPLeft = Arrays.copyOfRange(input, 0, splitSize);
        byte[] IPRight = Arrays.copyOfRange(input, splitSize, input.length);
        
        output = ArrayUtils.addAll(XOR(IPLeft,functionF(IPRight,key)),IPRight);
        
        return output;
    }
    
    //F Funcion
    public static byte[] functionF(byte[] byteArray, byte[] firstKey){
        byte[] result = new byte[byteArray.length];
        
        //EP (expansion Pbox)
        
        
        //split
        
        
        //S-boxes
        
        
        //P4
        int[] P4 = {2, 4, 3, 1};
        
        return result;
    }
    
    //permutation method 
    public static byte[] permutation(byte[] bytes, int[] p) {
        byte[] result = new byte[p.length];
        for (int n=0;n<p.length;n++)
            result[n] = bytes[p[n]-1];
        return result;
    }
        

    //XOR
    public static byte[] XOR(byte[] array1, byte[] array2) {
        byte[] xor = new byte[array1.length];
        for (int i = 0; i < array1.length; i++) 
            xor[i] = (byte) (array1[i] ^ array2[i]);
        return xor;
    }
    
    
    //left shift
    public static byte[] leftShift(byte[] array, int count){
        for (int i=0; i < count ; i++){
            int j;
            byte first;
            first=array[0];
            for(j=0; j < array.length-1; j++){
                array[j] = array[j+1];
            }
            array[j] = first;
        }
        return array;
    }
    
}


class KeyGen {
    private byte[] k1;
    private byte[] k2;
    
    public KeyGen(byte[] rawKey){
        int[] p10 = {3, 5, 2, 7, 4, 10, 1, 9, 8, 6};
        int[] p8 = {3, 7, 4, 8, 5, 10, 9};
        byte[] output = permutation(rawKey,p10);
        int splitSize = output.length/2;
        byte[] outputLeft = Arrays.copyOfRange(output, 0, splitSize);
        byte[] outputRight = Arrays.copyOfRange(output, splitSize, rawKey.length);
        output = ArrayUtils.addAll(leftShift(outputLeft,1),leftShift(outputRight,1));
        this.k1 = permutation(output, p8);
        output = ArrayUtils.addAll(leftShift(outputLeft,2),leftShift(outputRight,2));
        this.k2 = permutation(output, p8);
    }
  
    public byte[] getK1() {
        return k1;
    }
    
    public byte[] getK2() {
        return k2;
    }
    
    public static byte[] leftShift(byte[] array, int count){
        for (int i=0; i < count ; i++){
            int j;
            byte first;
            first=array[0];
            for(j=0; j < array.length-1; j++){
                array[j] = array[j+1];
            }
            array[j] = first;
        }
        return array;
    }
    
    public static byte[] permutation(byte[] bytes, int[] p) {
        byte[] result = new byte[p.length];
        for (int n=0;n<p.length;n++)
            result[n] = bytes[p[n]-1];
        return result;
    }
}
