import org.apache.commons.lang3.*;
import java.util.*;

public class SDES {

    byte[] s0 = {1,0,3,2,3,2,1,0,0,2,1,3,3,1,3,2};
    byte[] s1 = {0,1,2,3,2,0,1,3,3,0,1,0,2,1,0,3};

    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("Enter the length of the plaintext/ciphertext:");
        int n=scanner.nextInt();
        byte[] plainText = new byte[n];
        
        System.out.println("Enter byte values:");
        for(int i=0; i<n; i++)     
            plainText[i]=scanner.nextByte();
        
        System.out.println(".......................................\n");
        
        //
        // encrypt or decrypt
        //
        
    }
  
    //encrypt
    public static byte[] Encrypt(byte[] rawKey, byte[] plainText){
        byte[] cipher = new byte[plainText.length];
        
        
        //IP (initial permutation)
        int[] IP = {2, 6, 3, 1, 4, 8, 5, 7};
        
        //split 
        //int splitSize = plainText.length/2;
        //byte[] plainTextLeft = Arrays.copyOfRange(IPresult, 0, splitSize);
        //byte[] plainTextRight = Arrays.copyOfRange(IPresult, splitSize, rawKey.length);
        
        //generate keys
        KeyGen keyGen = new KeyGen(rawKey);
        byte[] K1 = keyGen.getK1();
        byte[] K2 = keyGen.getK2();
        
        
        
        
        //****************** F function
        
        
        //Swap
        
        public static byte[] SF(byte[] input){
        byte[] output = new byte[8];
        output[0] = input[4];
        output[1] = input[5];
        output[2] = input[6];
        output[3] = input[7];
        output[4] = input[0];
        output[5] = input[1];
        output[6] = input[2];
        output[7] = input[3];

        return output;
    }
        
        
        //round 2
        
        
        //IP-1 (inverse)
        int[] inverseIP = {4, 1, 3, 5, 7, 2, 8, 6};
        
        
        
        return cipher;
    }
    
    //decrypt
    public static byte[] Decrypt(byte[] rawkey, byte[] ciphertext){
        
        
    }
    
    /* permutation function
    
    public static byte[] permutation(byte[] bytes, int[] p) {
        byte[] result = new byte[p.length];
        for (int n=0;n<p.length;n++)
            result[n] = bytes[p[n]-1];
        return result;
    }
        
        
    }
    */
    
    //XOR
    public static byte[] XOR(byte[] array1, byte[] array2) {
        byte[] xor = new byte[array1.length];
        for (int i = 0; i < array1.length; i++) 
            xor[i] = (byte) (array1[i] ^ array2[i]);
        return xor;
    }
    
    //F Funcion
    public static byte[] FunctionF(byte[] byteArray, byte[] firstKey){
        byte[] result = new byte[byteArray.length];
        
        
        //EP (expansion Pbox)
     
    public static byte[] EP(byte[] array) {
        int[] epOrder = {4, 1, 2, 3, 2, 3, 4, 1};
        byte[] ep = new byte[8];

        for (int i=0; i<ep.length; i++) {
            ep[i] = array[epOrder[i]-1];
        }
        if (debug) {
            System.out.println("Expand and Permutate");
            printArray(ep);
        }
        return ep;
    }
        
        
        
        
        //S-boxes
        
        //P4
        int[] P4 = {2, 4, 3, 1};
        
        return result;
    }
}

class KeyGen {
    private byte[] k1;
    private byte[] k2;
    
    public KeyGen(byte[] rawKey){
        int[] p10 = {3, 5, 2, 7, 4, 10, 1, 9, 8, 6};
        int[] p8 = {3, 7, 4, 8, 5, 10, 9};
        // byte[] output = permutation(rawKey,p10)
        int splitSize = output.length/2;
        byte[] outputLeft = Arrays.copyOfRange(output, 0, splitSize);
        byte[] outputRight = Arrays.copyOfRange(output, splitSize, rawKey.length);
        output = ArrayUtils.addAll(LeftShift(outputLeft,1),LeftShift(outputRight,1));
        // this.k1 = permutation(output, p8)
        // output = ArrayUtils.addAll(LeftShift(outputLeft,2),LeftShift(outputRight,2));
        // this.k2 = permutation(output, p8)
    }
  
    public byte[] getK1() {
        return k1;
    }
    
    public byte[] getK2() {
        return k2;
    }
    
    public static byte[] LeftShift(byte[] array, int count){
        for (int i=0; i < count ; i++){
            int j;
            byte first;
            first=array[0];
            for(j=0; j < array.length-1; j++){
                array[j] = array[j+1];
            }
            array[j] = first;
        }
        return array;
    }  
}
